<?xml version="1.0"?>
<!-- $Id: SpreadsheetComponent.mxml 2500 2011-06-17 00:00:05Z tom $ 
     $Date: 2011-06-16 17:00:05 -0700 (Thu, 16 Jun 2011) $
     $Revision: 2500 $ -->
<!--
/**
 *  Latest information on this project can be found at http://www.rogue-development.com/spreadsheet/
 * 
 *  Copyright (c) 2008 Marc Hughes 
 * 
 *  Permission is hereby granted, free of charge, to any person obtaining a 
 *  copy of this software and associated documentation files (the "Software"), 
 *  to deal in the Software without restriction, including without limitation 
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 *  and/or sell copies of the Software, and to permit persons to whom the Software 
 *  is furnished to do so, subject to the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be included in all 
 *  copies or substantial portions of the Software.
 * 
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 *  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
 *  PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
 *  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 *  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 *
 * Description:
 *    A datagrid like component focused on data input and extensibility.
 * 
 **/
 This provides one example usage of the Spreadsheet component.
-->

<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:sp="com.roguedevelopment.spreadsheet.*" 	
	xmlns:kapit="fr.kapit.*" 
    xmlns:components="fr.kapit.components.*" 
    xmlns:diagctl="com.kapit.diagram.controls.*" 
    xmlns:diagview="com.kapit.diagram.view.*"
   	xmlns:kapit1="edu.isi.bmkeg.kefed.component.view.ui.kapit.*"	
	xmlns:ui="edu.isi.bmkeg.kefed.ui.*"               
	preinitialize="preinit()" xmlns:ui1="edu.isi.bmkeg.kefed.component.view.ui.*">
	
	<mx:Script>
	<![CDATA[
		import com.kapit.diagram.DiagramEvent;
		import com.kapit.diagram.layouts.utils.Constants;
		import com.kapit.diagram.library.SVGAssetLibrary;
		import com.kapit.diagram.model.DiagramModel;
		import com.kapit.diagram.proxies.DiagramProxy;
		import com.kapit.diagram.proxies.KDLProxy;
		import com.kapit.diagram.ui.Utils;
		import com.kapit.diagram.view.DiagramObject;
		import com.kapit.diagram.view.DiagramSprite;
		import com.kapit.diagram.view.DiagramView;
		
		import edu.isi.bmkeg.kefed.component.KefedComponent;
		import edu.isi.bmkeg.kefed.component.view.app.KefedAppEvent;
		import edu.isi.bmkeg.kefed.component.view.elements.KefedBaseValueTemplate;
		import edu.isi.bmkeg.kefed.component.view.elements.KefedExperiment;
		import edu.isi.bmkeg.kefed.component.view.elements.KefedFieldTemplate;
		import edu.isi.bmkeg.kefed.component.view.elements.KefedFullValueTemplate;
		import edu.isi.bmkeg.kefed.component.view.elements.KefedModel;
		import edu.isi.bmkeg.kefed.component.view.elements.KefedObject;
		import edu.isi.bmkeg.kefed.component.view.elements.KefedPersevereEvent;
		import edu.isi.bmkeg.kefed.component.view.elements.KefedPersevereInterface;
		import edu.isi.bmkeg.kefed.component.view.ontology.OntologySearchInterface;
		import edu.isi.bmkeg.kefed.component.view.ui.ComplexDataGridColumn;
		import edu.isi.bmkeg.kefed.component.view.ui.DataEntryCheckBoxFactory;
		import edu.isi.bmkeg.kefed.component.view.ui.DataEntryComboFactory;
		import edu.isi.bmkeg.kefed.component.view.ui.DataEntryEditorFactory;
		import edu.isi.bmkeg.kefed.component.view.ui.DataEntryLongEditorFactory;
		import edu.isi.bmkeg.kefed.component.view.ui.DataEntryRelativeRegionFactory;
		import edu.isi.bmkeg.kefed.component.view.ui.DataEntryUnitsFactory;
		import edu.isi.bmkeg.kefed.component.view.ui.DataGridComboBox;
		import edu.isi.bmkeg.kefed.component.view.ui.TextDisplayDialog;
		import edu.isi.bmkeg.kefed.component.view.ui.UiUtil;
		import edu.isi.bmkeg.kefed.component.view.ui.kapit.DiagramMappings;
		import edu.isi.bmkeg.kefed.component.view.ui.kapit.KefedLinkProxy;
		import edu.isi.bmkeg.kefed.component.view.ui.kapit.KefedObjectProxy;
		import edu.isi.bmkeg.utils.DataUtil;
		import edu.isi.bmkeg.utils.powerloom.PLExporter;
		
		import flare.vis.events.SelectionEvent;
		
		import flash.events.MouseEvent;
		import flash.net.FileReference;
		import flash.utils.ByteArray;
		
		import mx.charts.HitData;
		import mx.charts.chartClasses.DataTip;
		import mx.collections.ArrayCollection;
		import mx.controls.Alert;
		import mx.controls.TextInput;
		import mx.controls.dataGridClasses.DataGridColumn;
		import mx.controls.sliderClasses.Slider;
		import mx.core.Application;
		import mx.core.FlexGlobals;
		import mx.core.ScrollPolicy;
		import mx.events.DataGridEvent;
		import mx.events.ListEvent;
		import mx.events.SliderEvent;
		import mx.managers.PopUpManager;
		import mx.rpc.events.FaultEvent;
		import mx.utils.ArrayUtil;
		import mx.utils.ObjectUtil;
		import mx.utils.StringUtil;
	
		[Bindable]
		protected var dataTable:ArrayCollection = new ArrayCollection();
		
		[Bindable]
		protected var dataColumns:Array = null;
		
		[Bindable]
		protected var variableType:KefedFullValueTemplate = null;
	
		[Bindable]
		protected var activeVb:KefedObject;
		
		/** Ontology search interface to be used for term lookup.
	 	 *  Required for proper finding of ontology terms.
	 	 */
		[Bindable]
		public var termLookupService:OntologySearchInterface;

	
		[Bindable]
		protected var model:KefedExperiment = new KefedExperiment();

		[Bindable]
		protected var depVbs:ArrayCollection = new ArrayCollection();

		[Bindable]
		protected var indepVbs:ArrayCollection = new ArrayCollection();
		
		[Bindable]
		protected var cntrlVbs:ArrayCollection = new ArrayCollection();
		
		[Bindable]
		public var saveAllowed:Boolean = true;
		
	    private var _proxy:DiagramProxy;
	    
	    /** File references used for saving and loading spreadsheets.
	    *   Needs to be a field so that the scope is maintained
	    *   across multiple method calls.  Just extracting the
	    *   value from the Event's target fails.
	    */
	    private var saveFileRef:FileReference = null;
	    private var loadFileRef:FileReference = null;

		public function initDiagram():void {
            _proxy = new KDLProxy(diagram);
            diagram.multipanel=false;
            diagram.selectionenabled=true;
            diagram.keyboardenabled=false;
            diagram.dragenabled=false;
            diagram.dropenabled=false;
            var sprites:Array = [];
	
			var diagModel:DiagramModel = new DiagramModel(DiagramMappings.getDiagramMappings());
			
			diagram.model = diagModel;

			if( diagram != null && _proxy != null) {

				diagram.addEventListener(DiagramEvent.SELECTION_CHANGED,
							handleDiagramSelectionChanged);
	
	            _proxy.importGraph();
	            _proxy.exportGraph(Constants.RADIAL_LAYOUT);
	
            }    

			this.loadModel(this.model);

        }
        
		public function loadModel(model:KefedExperiment):void {
        	
            this.model = model;
			this.depVbs = DataUtil.sortCollectionAlphabetically(model.getMeasurements(), "nameValue", false);
			this.indepVbs = DataUtil.sortCollectionAlphabetically(model.getParameters(), "nameValue", false);
			this.cntrlVbs = DataUtil.sortCollectionAlphabetically(model.getConstants(), "nameValue", false);
			
			// Hack: loading the model the 2nd time triggers the 
			// editing updates when you load the diagram from XML
			// Having this temporary model that gets edited by 
			// the update and then discarded fixes the problem
			var tempModel:KefedModel = new KefedModel();
			KefedObjectProxy._graph = tempModel;
			KefedLinkProxy._graph = tempModel;
			
			if( diagram != null && _proxy != null) {

				this.diagram.fromXML(model.diagramXML);
				_proxy.importGraph()
	            
	            zoomControl.setZoom(0.5);
           }    
			
			KefedObjectProxy._graph = model;
			KefedLinkProxy._graph = model;
			
			diagram.deselectAll();			
        }
       
       
  
	/* Generate the PowerLoom string for the data in this model and 
	   show it in a dialog box. */	
	public function showModelPowerLoom(event:MouseEvent):void {
			var d:TextDisplayDialog = new TextDisplayDialog();
			d.title="PowerLoom Representation";
			d.displayText=PLExporter.generateExperimentDataAssertion(model, true);
			PopUpManager.addPopUp(d, this);
		}
		
		public function saveCurrentModel(event:MouseEvent, exit:Boolean):void {
	        var diagramXml:XML = diagram.toXML();
			model.diagramXML = diagramXml;
			model.modelName = modelName.text;
			model.source = modelSource.text;
			model.citeKey = modelCitation.text;
			
			var kefedComp:KefedComponent = KefedComponent(FlexGlobals.topLevelApplication.kefedComponent);
			if(kefedComp.eventDispatcher != null ) {
				kefedComp.eventDispatcher.dispatchBioScholarEvent(KefedAppEvent.SAVE_DATA_EDIT, model);
			}
			if (exit) {
				currentState = "";
				kefedComp.currentState = "Dashboard_State";
			}
		}

		public function cancelSave(event:MouseEvent):void {

			var kefedComp:KefedComponent = KefedComponent(FlexGlobals.topLevelApplication.kefedComponent);
			if(kefedComp.eventDispatcher != null ) {
				kefedComp.eventDispatcher.dispatchBioScholarEvent(KefedAppEvent.CANCEL_DATA_EDIT);
				currentState = "";
				kefedComp.currentState = "Dashboard_State";
			}
		}
		
		private function selectConstant (variable:KefedObject):void {
			activeVb = variable;
			currentState = "ConstantSpecification_State";
			variableType = activeVb.valueType;
		}
		
		private function selectParameter(variable:KefedObject):void {
			activeVb = variable;
			currentState = "ParameterSpecification_State";
			variableType = activeVb.valueType;
		}
		
		private function selectMeasurement(variable:KefedObject):void {
			activeVb = variable;
			currentState = "MeasurementSpecification_State";
			buildMeasurementVariableDataGrid(activeVb, depVbData);
			if (model.experimentData[activeVb.uid] == null) {
				model.experimentData[activeVb.uid] = new ArrayCollection();
			}
			dataTable = model.experimentData[activeVb.uid]; 
		}

		/** Lookup the element UID for the list, and if found, then select the 
		 *  element in the grid and go to the new state and return true.
		 *  If an element with uid is not in the elementList, then
		 *  do nothing and return false.
		 * 
		 * @param uid The UID to lookup in the elementList
		 * @param elementList List of elements to check
		 * @param grid DataGrid that displays the elements from elementList
		 * @param newState The state to enter if the element is found.
		 * @returns true if the element is found, otherwise false.
		 */
		private function lookupElementInList(uid:String,
		  									 elementList:ArrayCollection,
		  									 grid:List,
		  									 newState:String):Boolean {
			for(var i:int=0;i<elementList.length;i++) {
				if (elementList[i].uid == uid) {         
					grid.selectedIndex = i;
		 			selectElementInGrid(grid, elementList, newState);
					return true;	
				}
			}
			return false;			
		}
		
		/** Handle selection changes from the diagram.  This is the main
		 *  selection change handling routine.  Selection changes from the
		 *  lists of variables will indirectly call this by arranging to 
		 *  change the diagram selection when the list selection changes.
		 * 
		 *  That will trigger this routine to be called by the diagram code.
		 */
		private function handleDiagramSelectionChanged(e:Event):void
		{
			var arr:Array=diagram.getSelectedObjects();
			
			var uid:String = null;
			var type:String = null;
			var dObj:DiagramObject = null;
			if( arr && arr.length == 1 ) { 
				dObj = DiagramObject(arr[0]);
				uid = dObj.dataobjectid;
			}
			
			if(uid) {
				// Rather inefficient code that goes through each of the
				// variable arrays and tries to find out what type of
				// variable has been selected.  It then updates the selection
				// for the data part of the interface.
				if (lookupElementInList(uid, depVbs, depVbGrid, "MeasurementSpecification_State")) return;
				if (lookupElementInList(uid, indepVbs, indepVbGrid, "ParameterSpecification_State")) return;
				if (lookupElementInList(uid, cntrlVbs, cntrlVbGrid, "ConstantSpecification_State")) return;
			} 

			// If we got here, then no variable object was selected.
			// So we reset the lists to not have anything selected and then 
			// reset the state to the default state.
			indepVbGrid.selectedIndex = -1;
			cntrlVbGrid.selectedIndex = -1;			            
			depVbGrid.selectedIndex = -1;
			currentState = "";
		}
		
		protected function preinit() : void {

			var kefedComp:KefedComponent = KefedComponent(FlexGlobals.topLevelApplication.kefedComponent);
			if(kefedComp.eventDispatcher != null ) {
				kefedComp.eventDispatcher.addEventListener(KefedAppEvent.EDIT_DATA, loadModelEventListener);
			}
		}
		
		public function loadModelEventListener(event:KefedAppEvent):void {
			this.loadModel(event.activeModel as KefedExperiment);
		}
		
		private function selectDiagramElement(element:KefedObject):void {
            diagram.deselectAll();
            if (element) {
         		var uid:String = element.uid;
           		var dob:DiagramObject = DiagramObject(diagram.getElementByDataObjectId(uid));
	            diagram.selectObject(dob);
	        }
		}
		
		private function deselectNonMatchingList (current:List, target:List):void {
			if (current != target) target.selectedIndex = -1;
		}
		
		
		/** Handle the selection of an element in a grid.  This function takes
		 *  care of updating the other variable grids by deselecting any selections,
		 *  and it sets up the editing for either type editing (Control and Parameters)
		 *  or data editing (Measurements).
		 * 
		 *  Sets "activeVb" to be the currently selected variable, or null if there
		 *  is no selected variable.
		 *
		 * @param grid The selection grid that is being handled.
		 * @param variables Collection of the variables associated with the grid.
		 * @param newState The new editing state to enter if a variable is selected.
		 */
		 private function selectElementInGrid(grid:List,
											  variables:ArrayCollection,
											  newState:String):void {
			deselectNonMatchingList(grid, depVbGrid);
			deselectNonMatchingList(grid, indepVbGrid);
			deselectNonMatchingList(grid, cntrlVbGrid);
			
			if (grid.selectedIndex >= 0) {          
				activeVb = variables[grid.selectedIndex];
				if (activeVb.isMeasurement()) {
					buildMeasurementVariableDataGrid(activeVb, depVbData);
					if (model.experimentData[activeVb.uid] == null) {
						model.experimentData[activeVb.uid] = new ArrayCollection();
					}
					dataTable = model.experimentData[activeVb.uid];
				} else {
					variableType = activeVb.valueType;
				}
				currentState = newState;
			} else {
				activeVb = null;
				diagram.deselectAll();
				currentState = "";
			}
		}
		
		private function selectListElement(event:Event):void {
			var list:List = event.currentTarget as List;
			selectDiagramElement(list.selectedItem as KefedObject);
		}
		
		/** Builds the data grid for a measurement variable.
		 */		
		private function buildMeasurementVariableDataGrid(depV:KefedObject, depVbData:DataGrid):void {
            	
            if( !depV.isMeasurement() ) {
            	return;
            }	
            	
        	//
        	// Go back through graph and build pathways from all independent 
        	// variables and the current dependent variable.
        	// 
        	// TODO: Should this also pick up controlled variables and show
        	//       them in context?
         	var dependOnsArray:ArrayCollection = model.getDependOnsForMeasurement(depV);
 			var cols:Array = new Array();
			
			// Make array for independent variables
        	for(var i:int=0; i<dependOnsArray.length; i++) {
        		createVariableDataRenderer(dependOnsArray[i] as KefedObject, cols);
        	}
 
        	// Now handle the Dependent variable structure as well.
        	createVariableDataRenderer(depV, cols);
 			
			dataColumns = cols;
        }
        
        /** Create a variable data renderer of the appropriate type and
        *   stores it into the column array.
        * 
        * @param variable The variable object
        * @param renderers Array for holding the data renderers.
        */
        private function createVariableDataRenderer(variable:KefedObject, renderers:Array):void {
        	var dgc:DataGridColumn;
        	
           	if (variable.valueType.valueTypeName == "Table") {
        		for each (var field:KefedFieldTemplate in variable.valueType.multipleSlotFields) {
        			dgc = new ComplexDataGridColumn();
        			// Hack:  Include a space after the "." to allow the headerline
        			//        to word wrap at that position.
        			dgc.headerText = variable.nameValue + ". " + field.nameValue;
        			dgc.dataField = variable.uid + "." + field.uid;
        			dgc.headerWordWrap = true;
        			dgc.showDataTips = true;
					setupItemRendererForType(dgc, field.valueType);
					renderers.push(dgc);
        		}
        	} else {
        		dgc = new ComplexDataGridColumn();
        		dgc.headerText = variable.nameValue;
        		dgc.dataField = variable.uid;
       			dgc.showDataTips = true;
        		dgc.headerWordWrap = true;
				setupItemRendererForType(dgc, variable.valueType);
				renderers.push(dgc);	
        	}
        }
        
        /** Decides which data renderer is most appropriate for the type and
        *   template information that is stored for this item.  Then sets the
        *   DataGridColumn appropriately for handling that data renderer.
        * 
        * @param dgc The datagrid column to setup for the item
        * @param vTemplate The base value template for the item
         */
        private function setupItemRendererForType (dgc:DataGridColumn, vTemplate:KefedBaseValueTemplate):void {
        	if (vTemplate.valueTypeName == "True/False") {
				dgc.itemRenderer = new DataEntryCheckBoxFactory(vTemplate);
				dgc.editorDataField = "selected";
				dgc.rendererIsEditor = true;
        	} else if (vTemplate.valueTypeName == "Image"
        				|| vTemplate.valueTypeName == "File") {
        		dgc.itemRenderer = new DataEntryEditorFactory(vTemplate);
        		dgc.rendererIsEditor = true;
        	} else if (vTemplate.valueTypeName == "Date") {
				dgc.itemRenderer = new DataEntryEditorFactory(vTemplate);
				dgc.rendererIsEditor = true;
        	} else if (vTemplate.valueTypeName == "Time") {
				dgc.itemRenderer = new DataEntryEditorFactory(vTemplate);
				dgc.rendererIsEditor = true;
        	} else if (vTemplate.valueTypeName == "DateTime") {
				dgc.itemRenderer = new DataEntryEditorFactory(vTemplate);
				dgc.rendererIsEditor = true;
        	} else if (vTemplate.valueTypeName == "Decimal with units") {
        		dgc.labelFunction = unitsLabelFunction;
        		dgc.itemEditor = new DataEntryUnitsFactory(vTemplate);
				dgc.editorDataField = "dataItem";
        		dgc.rendererIsEditor = false;
        		dgc.showDataTips = true;
        		dgc.dataTipFunction = unitsDataTipFunction;
			} else if (vTemplate.valueTypeName == "Region") {
				dgc.labelFunction = regionLabelFunction;
        		dgc.itemEditor = new DataEntryRelativeRegionFactory(vTemplate);
//        		var t:RelativeRegionEditor = dgc.itemEditor.newInstance() as RelativeRegionEditor;
//        		t.computeSize();
//        		trace("Editor=",t," h=",t.measuredHeight," w=",t.measuredWidth);
				dgc.editorDataField = "dataItem";
				dgc.editorHeightOffset = RelativeRegionEditor.EDITOR_HEIGHT_OFFSET;
				dgc.editorWidthOffset = RelativeRegionEditor.EDITOR_WIDTH_OFFSET;
        		dgc.rendererIsEditor = false;
        		dgc.dataTipFunction = regionDataTipFunction;
  			} else if (vTemplate.valueTypeName == "Text"
  						|| vTemplate.valueTypeName == "Decimal"
  						|| vTemplate.valueTypeName == "Integer") {
//  				dgc.itemRenderer = new DataEntryEditorFactory(vTemplate);
//				dgc.rendererIsEditor = true;
				dgc.itemEditor = new DataEntryEditorFactory(vTemplate);
				dgc.dataTipFunction = simpleDataTipFunction;
			} else if (vTemplate.valueTypeName == "Long Text") {
//				dgc.itemRenderer = new DataEntryLongEditorFactory(vTemplate);
//				dgc.rendererIsEditor = true;
				dgc.editorHeightOffset = RelativeRegionEditor.EDITOR_HEIGHT_OFFSET;
				dgc.editorWidthOffset = RelativeRegionEditor.EDITOR_WIDTH_OFFSET;
				dgc.itemEditor = new DataEntryLongEditorFactory(vTemplate);
				dgc.dataTipFunction = simpleDataTipFunction;
			} else if (vTemplate.allowedValues.length > 0) {
//				dgc.itemRenderer = new DataEntryComboFactory(vTemplate);
//				dgc.rendererIsEditor = true;
				dgc.itemEditor = new DataEntryComboFactory(vTemplate);
				dgc.dataTipFunction = simpleDataTipFunction;
			} else {
//				dgc.itemRenderer = new DataEntryEditorFactory(vTemplate);
//				dgc.rendererIsEditor = true;
				dgc.itemEditor = new DataEntryEditorFactory(vTemplate);
				dgc.dataTipFunction = simpleDataTipFunction;
			}
        }
        
        private function formatUnits(unitsObject:Object):String {
        	if (unitsObject) {
        		if (unitsObject.value) {
        			if (unitsObject.units) {
        				return unitsObject.value + " " + unitsObject.units;
        			} else { // Value but no units
        				return unitsObject.value;
        			}
        		} else if (unitsObject.units) { // units but no value
        			return unitsObject.units;
        		} else {
        			return "";
        		}
        	} else {
        		return "";
        	}
        }
        
        private function unitsLabelFunction(item:Object, col:DataGridColumn):String {
        	return formatUnits(DataUtil.getNestedValue(item, col.dataField));
        }
        
        private function formatRegion(regionObject:Object):String {
        	if (regionObject) {
        		return regionObject.relation + " " + (regionObject.regions as Array).join(",");
	        } else {
	        	return "";
	        }
        }
        
        private function regionLabelFunction(item:Object, col:DataGridColumn):String {
        	return formatRegion(DataUtil.getNestedValue(item, col.dataField));
         }
        
        private function regionDataTipFunction(data:Object):String {
        	return (data) ? formatRegion(data) : "";
        }
        
        private function unitsDataTipFunction(data:Object):String {
        	return (data) ? data.value + " " + data.units : "";
        }
        
        private function simpleDataTipFunction(data:Object):String {
        	return (data) ? data.toString() : "";
        }
		
		/** Constructs a tab-delimited "spreadsheet" structure and returns it
		 *  along with any data that is already entered for the variables.
		 * 	The structure will be determined as follows:
		 * 	Row 1: The UIDs of the variable or variable.field
		 *  Row 2: The name of the variable for variable: field
		 * 	Row 3+: Data values
		 *  For values with units or region values, there will be additional
		 * 	  subfields for "value" and "units" or "relation" "region-list"
		 *  Region subfields can have multiple values separated by ";"
		 * 
		 * @param measurementVar The measurement variable for this spreadsheet.
		 * @returns A string with the spreadsheet format.
		 */
	    public function buildMeasurementVariableSpreadsheetString(measurementVar:KefedObject):String {
			var ss:String = "";
	        if( measurementVar == null || !measurementVar.isMeasurement() ) {
	        	return ss;
	        }
	        
	        var ssheet:ArrayCollection = buildMeasurementVariableInputArray(measurementVar, true);
	        for each (var row:Object in ssheet) {
	        	ss += (row as ArrayCollection).source.join("\t") + "\n";
	        }
	        return ss;
	    }
	    
	    /** Builds a spreadsheet array
	     * 	The structure will be determined as follows:
		 * 	Row 1: The UIDs of the variable or variable.field
		 *  Row 2: The name of the variable for variable: field
		 * 	Row 3+: Data values
		 *  For values with units or region values, there will be additional
		 * 	  subfields for "value" and "units" or "relation" "region-list"
		 *  Region subfields can have multiple values separated by ";"
		 * 
		 * @param measurementVar the measuremnt for which to construct a spreadsheet
		 * @param includeData flag to control inclusion of data in array
		 * @return An ArrayCollection of rows, each row being an array of columns
		 */
	    public function buildMeasurementVariableInputArray(measurementVar:KefedObject,
	    												   includeData:Boolean):ArrayCollection {
	    	var table:ArrayCollection = new ArrayCollection();

			// TODO:  Should this also display the controlled variable values?
			var dependOns:ArrayCollection = this.model.getDependOnsForMeasurement(measurementVar);
	
			// First row sets the variable uids
			// Second row sets the human readable names
			// TODO: Need to set the autoCompletionOptions.
		    var row1:ArrayCollection = new ArrayCollection();
			var row2:ArrayCollection = new ArrayCollection();			
			for each ( var variable:KefedObject in dependOns) {
				addHeaderRowElement(variable, "uid", ".", row1);
				addHeaderRowElement(variable, "nameValue", ": ", row2);				
			}
			addHeaderRowElement(measurementVar, "uid", ".", row1);
			addHeaderRowElement(measurementVar, "nameValue", ": ", row2);
			table.addItem(row1);
		    table.addItem(row2);
		    
		    if (includeData) {
				for each (var dataRow:Object in model.experimentData[measurementVar.uid]) {
					var rowN:ArrayCollection = new ArrayCollection();
					for each (variable in dependOns) {
						addDataRowElement(variable, dataRow[variable.uid], rowN);			
					}
					addDataRowElement(measurementVar, dataRow[measurementVar.uid], rowN);
					table.addItem(rowN);
				}
		    }
			return table;
	    }
	    
	    /** Add a header row element for the variable, using the slotName
	     *  and delimiter to construct the string to return for each element.
	     * 
	     * @param variable The particular variable that the element is added for.
	     * @param slotName The slotName to use to get the value for the header.
	     * @param delimiter The delimiter to use to separate hiearchical elements.
	     * @param row The ArrayCollection that will be modified.
	     */
	    private function addHeaderRowElement(variable:KefedObject,
	    									 slotName:String,
	    									 delimiter:String,
	    									 row:ArrayCollection):void {
	    	var datatype:KefedFullValueTemplate = variable.valueType;
	    	var datatypeName:String = datatype.valueTypeName;
			if (datatypeName == "Table") {
				for each (var field:KefedFieldTemplate in datatype.multipleSlotFields) {
					addHeaderElement(variable[slotName] + delimiter + field[slotName], delimiter, field.valueType, row);
				}
			} else {
				addHeaderElement(variable[slotName], delimiter, datatype, row);
			}
		}
		
		private function addHeaderElement(prefix:String,
										  delimiter:String,
										  datatype:KefedBaseValueTemplate,
										  row:ArrayCollection):void {
			if (datatype.valueTypeName == "Region") {
				row.addItem(prefix + delimiter + "relation");
				row.addItem(prefix + delimiter + "regions");
			} else if (datatype.valueTypeName == "Decimal with units") {
				row.addItem(prefix + delimiter + "value");
				row.addItem(prefix + delimiter + "units");
			} else {
				row.addItem(prefix);
			}
		}
		
 	    
	    /** Add a data row element for the variable, using the data from
	     *  a particular row in the stored data.
	     * 
	     * @param variable The particular variable that the element is added for.
	     * @param datum The object with the values for this object.
	     * @param row The ArrayCollection that will be modified.
	     */
	    private function addDataRowElement(variable:KefedObject,
	    								   datum:Object,
	    								   row:ArrayCollection):void {
			if (variable.valueType.valueTypeName == "Table") {
				for each (var field:KefedFieldTemplate in variable.valueType.multipleSlotFields) {
					var fieldValue:Object = (datum == null) ? "" : datum[field.uid];
					addDataElement(fieldValue, field.valueType, row);
				}
			} else {
				addDataElement(datum, variable.valueType, row);
			}
		}
		
		private function addDataElement(value:Object,
										datatype:KefedBaseValueTemplate,
										row:ArrayCollection):void {
			if (datatype.valueTypeName == "Region") {
				row.addItem((value == null) ? "" : value.relation.toString());
				row.addItem((value == null) ? "" : (value.regions as Array).join(";"));
			} else if (datatype.valueTypeName == "Decimal with units") {
				row.addItem((value == null) ? "" : value.value.toString());
				row.addItem((value == null) ? "" : value.units.toString());
			} else {
				row.addItem((value == null) ? "" : value.toString());
			}
		}

 
        private function handleAddRowEditDependentVariableData():void {   	
            var ac:ArrayCollection = ArrayCollection(depVbData.dataProvider);
            var o:Object = model.buildDependentVariableDataObject(activeVb, null);
            ac.addItem(o);
			depVbData.selectedIndex = ac.length - 1;
            }
        
        private function handleCopySelectedRowEditDependentVariableData():void {
        	var ac:ArrayCollection = ArrayCollection(depVbData.dataProvider);
            var o:Object = model.buildDependentVariableDataObject(activeVb, depVbData.selectedItem);
        	ac.addItem(o);
 			depVbData.selectedIndex = ac.length - 1;
        }
        
        private function handleCopyLastRowEditDependentVariableData():void {
        	var ac:ArrayCollection = ArrayCollection(depVbData.dataProvider);
            var o:Object = model.buildDependentVariableDataObject(activeVb, ac.getItemAt(ac.length - 1));
        	ac.addItem(o);
 			depVbData.selectedIndex = ac.length - 1;
        }

        private function handleRemoveRowEditDependentVariableData():void {
			var dg:DataGrid = DataGrid(this.depVbData);
			var ac:ArrayCollection = ArrayCollection(dg.dataProvider);
            var i:int = dg.selectedIndex;
            if( i == -1 ) {
            	i = ac.length - 1;
            }
            ac.removeItemAt(i);
        }

         private function switchToSpreadsheet(): void {
        	if (this.activeVb.isMeasurement()) {
 	        	currentState = "Spreadsheet_State";
        		this.spreadsheet.text = buildMeasurementVariableSpreadsheetString(activeVb);
        		this.checkDataButton.enabled = false;
        		this.loadToGridButton.enabled = false;
	        }	
        }
        
        private function switchFromSpreadsheet(): void {
        	if( this.activeVb.isMeasurement()) {
        		selectMeasurement(activeVb);
			} else if( this.activeVb.isParameter()) { 	
	        	selectParameter(activeVb);
			} else if( this.activeVb.isConstant()) { 	
				selectConstant(activeVb);
  			} else {
   				currentState = '';
   			}
        }

		private function getSpreadsheetErrorStrings(): String {
			var error:String = "";
        	var ss:String = this.spreadsheet.text;
        	var re:RegExp = /[\n\r]+/;
        	var lines:Array = ss.split(re);
      	if (lines.length < 2) {
        		return "Not enough rows.  Must have two header rows\nRow 1 with IDs and Row 2 with names.\n";
        	}
        	var uids:Array = lines[0].split("\t");
	       	var names:Array = lines[1].split("\t");
        	
        	// Get array of headers to check the table structure.
        	var ssHeaders:ArrayCollection = buildMeasurementVariableInputArray(this.activeVb, false);
        	var uidBase:ArrayCollection = ssHeaders[0] as ArrayCollection;
        	var ssWidth:int = uidBase.length;
 
         	// Check to make sure that the variable names are correct.
        	if (uids.length != ssWidth) {
        		error += "ID row is too " + ((uids.length < ssWidth) ? "short" : "long") + ".\n";
        	}
        	if (names.length != ssWidth) {
        		error += "Names row is too " + ((names.length < ssWidth) ? "short" : "long") + ".\n";
        	}
        	for (var i:int=0; i < uids.length; i++) {
        		if (uidBase.getItemIndex(uids[i]) == -1) {
        			error += "Variable " + names[i] + " not found in design. UID=" + uids[i] + "\n";
        		}
        	}

			// Check data length.
			if (error.length == 0) { // Skip if we have other trouble.
        		for(i=2; i<lines.length; i++) {
        			var line:String = lines[i];
        			if (line != "") { // Ignore blank data lines.
	        			var row:Array = line.split("\t");
	        			// We allow short lines to handle the case where trailing
	        			// values are not specified.  These are not written by
	        			// Excel when saving as a tab-separated file.
	        			if( row.length > ssWidth ) {
	        				error += "Row " + (i+1) + " is too " + ((row.length < ssWidth) ? "short" : "long") 
	        						 + ". [length=" + row.length + "]\n";
	        			}
	        		}
        		}
        	} else {
        		error += "Headers are incorrect.  Data checking not done.\n";
        	}
        	
			return error;			
		}


        private function checkSpreadsheetData(): void {
 			var error:String = this.getSpreadsheetErrorStrings();        	
        	if (error.length == 0) {
        		Alert.show("Data passes check.");
        	} else {
        		Alert.show(error);
        	}
         }

        private function loadSpreadsheetDataToGrid(): void {
        	var error:String = this.getSpreadsheetErrorStrings();        	
        	if (error.length > 0) {
        		Alert.show(error + "\n\nData upload canceled.");
        		return;
        	}
        	
        	var ss:String = this.spreadsheet.text;
        	var re:RegExp = /[\n\r]+/;
        	var lines:Array = ss.split(re);
         	var uids:Array = lines[0].split("\t");
         	var nCols:int = uids.length;

			// Go through the data lines and load the data for all non blank 
			// lines.  Use the column index with the uids line to find the
			// appropriate path to set for the data.
			var dataArray:ArrayCollection = new ArrayCollection;
       		for(var i:int=2; i<lines.length; i++) {
       			var line:String = lines[i];
       			if (line != "") { // Ignore blank data lines.
        			var row:Array = line.split("\t");
        			var rowSize:int = row.length;
        			var datum:Object = new Object();
        			for (var col:int=0; col<nCols; col++) {
        				// Here we set the data for each column
        				// and handle the case where the last values 
        				// are not specified.
        				var value:* = (col < rowSize) ? row[col] : "";
        				// Handle multiple values for region entry.
        				if ((uids[col] as String).search(/\.regions$/) != -1) {
        					value = (value == "") ? [] : (value as String).split(";");
        				}
       					DataUtil.setNestedValue(datum, uids[col], value);
        			}
        			dataArray.addItem(datum);
	        	}
        	}
        	model.experimentData[activeVb.uid] = dataArray;
    
        	this.switchFromSpreadsheet();
        }
        
        private function saveSpreadsheetFile():void {
        	saveFileRef = new FileReference();
        	saveFileRef.addEventListener(Event.COMPLETE, saveCompleted)
        	var defaultFilename:String = activeVb.nameValue.replace(/ /g, "-") + ".txt";
        	saveFileRef.save(this.spreadsheet.text, defaultFilename);
        }
        
        private function saveCompleted(evt:Event):void {
        	saveFileRef = null; // Release resources
        }
        
        private function loadSpreadsheetFile():void {
        	loadFileRef = new FileReference();
        	loadFileRef.addEventListener(Event.SELECT, fileSelected);
 	      	loadFileRef.addEventListener(Event.COMPLETE, loadCompleted)
	       	loadFileRef.addEventListener(FaultEvent.FAULT, faultHandler);
           	loadFileRef.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        	try {
         		loadFileRef.browse();
            } catch (error:Error) {
            	Alert.show("Error reading file data: " + error, "ERROR");
            }
        }
        
        private function fileSelected(evt:Event):void {
        	// trace("Selected, preparing to load. name=" + fileRef.name + " date=" + fileRef.creationDate);
 	      	try {
        		loadFileRef.load();
         	} catch (error:Error) {
         		Alert.show("Error reading file data: " + error, "ERROR");
          	}
        }
        
        private function loadCompleted(evt:Event):void {
        	// trace("File size = " + fileRef.data.length);
        	try {
        		this.spreadsheet.text = loadFileRef.data.readMultiByte(loadFileRef.data.length, "iso-8859-1");
        		this.checkDataButton.enabled=true;
        		this.loadToGridButton.enabled=true;
        	} catch (error:Error) {
        		Alert.show("Error reading file data: " + error, "ERROR");
        	}
        	loadFileRef=null; // To free data storage.
        }

        private function doDebug(event:Event):void {
        	return;
        }
        
        private function spreadsheetCreatedHandler(event:Event):void {
        	spreadsheet.mx_internal::getTextField().useRichTextClipboard = false;
        }
        
//        private function handleEndEditEvent(event:DataGridEvent):void {
//        	if (false && event.itemRenderer is StructuredEditorComponent) {
//        		(event.itemRenderer as StructuredEditorComponent).updateEditedData(event);
//        	}
//        	return;
//        }

			public function faultHandler(event:FaultEvent):void {
				Alert.show(UiUtil.getFaultURL(event) + "\n"
				           + event.fault.faultString + "\n"
					   + event.fault.faultDetail, 
					   "Error");
			}
		
			public function errorHandler(event:Event):void {
				Alert.show("IO Error: " + event, "Error");
			}

		]]>
	</mx:Script>
	
	<mx:Style>
         .rightBold {
            fontWeight: bold;
            textAlign: right;
        }
        
        .centerBold {
        	fontWeight: bold;
        	textAlign: center;
        }
        
        .leftBold {
        	fontWeight: bold;
        	textAlign: left;
        }
    </mx:Style>
	
	<mx:states>
		<mx:State name="ConstantSpecification_State">
			<mx:RemoveChild target="{activeObjectForm}"/>
			<mx:AddChild relativeTo="{dataGrid}">
				<mx:VBox height="100%" width="100%">
					<ui1:VariableTemplateTabs myObject="{activeVb}" diagram="{diagram}"
						    termLookupService="{termLookupService}"
							monotonic="true" enabled="true"/>
				</mx:VBox>
			</mx:AddChild>
		</mx:State>
		<mx:State name="ParameterSpecification_State">
			<mx:RemoveChild target="{activeObjectForm}"/>
			<mx:AddChild relativeTo="{dataGrid}">
				<mx:VBox height="100%" width="100%">
					<ui1:VariableTemplateTabs myObject="{activeVb}" diagram="{diagram}"
						    termLookupService="{termLookupService}"
							monotonic="true" enabled="true"/>
				</mx:VBox>
			</mx:AddChild>
		</mx:State>
		<mx:State name="MeasurementSpecification_State">
			<mx:RemoveChild target="{activeObjectForm}"/>
			<mx:AddChild relativeTo="{dataGrid}" creationPolicy="all">
				<mx:VBox height="100%" width="100%">
					<mx:Text text="{activeVb.nameValue}" fontSize="14" fontWeight="bold"/>
					<!-- Need to turn off sorting, because it doesn't work correctly when a
					     complex dotted sort field form is used in the DataGrid. 
					     TODO: Investigate whether AdvancedDataGrid solves this problem, or
					           perhaps if Flex 4 may have fixed it. -->
					<mx:DataGrid id="depVbData" 
								dataProvider="{dataTable}"
								columns="{dataColumns}"
								sortableColumns="false"
								width="100%" 
								height="100%" 
								editable="true"
								horizontalScrollPolicy="{ScrollPolicy.ON}"
								variableRowHeight="true"
								headerStyleName="leftBold"
								/>		<!-- itemEditEnd="handleEndEditEvent(event)" -->
					<mx:HBox width="100%">
						<mx:Button label="Add Row" 
								click="handleAddRowEditDependentVariableData()"/>
					    <mx:Button id ="CopySelectedDataRowButton"
					    		enabled="{depVbData.selectedIndex != -1}"
					    		label="Copy Row"
					    		click="handleCopySelectedRowEditDependentVariableData()"/>
					    <mx:Button id="CopyLastDataRowButton"
					    		enabled="{dataTable.length > 0}"
					    		label="Copy Last Row"
					    		click="handleCopyLastRowEditDependentVariableData()"/>
						<mx:Button id="RemoveDataRowButton"
							    label="Remove Row"
								enabled="{depVbData.selectedIndex != -1}"
								click="handleRemoveRowEditDependentVariableData()"/>
						<mx:Spacer width="100%"/>
						<mx:Button id="createSpreadsheetButton"
								label="Spreadsheet"
								enabled="true"
								click="switchToSpreadsheet()"/>
						<!-- <mx:Button id="loadSpreadsheetButton"
								label="Load Spreadsheet"
								enabled="{depVbData.selectedIndex != -1}"
								click="handleLoadSpreadsheet()"/>\
						-->
					</mx:HBox>
				</mx:VBox>		
			</mx:AddChild>
		</mx:State>
		<mx:State name="Spreadsheet_State">
			<mx:RemoveChild target="{activeObjectForm}"/>
			<mx:AddChild relativeTo="{dataGrid}">
				<mx:VBox height="100%" width="100%">
					<mx:TextArea id="spreadsheet" height="100%" width="100%"
								 creationComplete="spreadsheetCreatedHandler(event)"/> 
					<mx:HBox width="100%">
						<mx:Button label="Save File"
								click="saveSpreadsheetFile()"/>
						<mx:Button label="Load File"
								click="loadSpreadsheetFile()"/>
						<mx:Spacer width="100%"/>
						<mx:Button id="checkDataButton" label="Check Data" 
								click="checkSpreadsheetData()"
								enabled="false"/>
						<mx:Button id="loadToGridButton" label="Load to Grid"
								click="loadSpreadsheetDataToGrid()"
								enabled="false"/>
						<mx:Button label="Cancel Batch"
								click="switchFromSpreadsheet()"/>
					</mx:HBox>
				</mx:VBox>		
			</mx:AddChild>
		</mx:State>
	</mx:states>
	<mx:HDividedBox width="100%" height="100%">
	
		<mx:Panel id="flatPanel" width="40%" height="100%" title="{model.modelName}" 
					backgroundAlpha="{flatPanel.getStyle('borderAlpha')}" 
					backgroundColor="{flatPanel.getStyle('borderColor')}" >                
				
			<mx:HBox width="100%" height="30" verticalAlign="middle" >

				<mx:Text text="Zoom: "/>
				<kapit1:DiagramZoomHSlider id="zoomControl"
			        	minimum="0" maximum="1.7" value="0.5" diagram="{diagram}"/>
			</mx:HBox>
			<mx:HBox width="100%" height="100%" verticalAlign="middle" >
				<diagview:DiagramView width="100%" height="100%" id="diagram" creationComplete="initDiagram();"/>
			</mx:HBox>
		</mx:Panel>
		<mx:VBox height="100%" width="100%">
			<mx:HBox width="100%">
				<!-- <mx:Label text="Design:" fontSize="12"/> -->
				<mx:Label text="{model.type}" fontSize="18" />
				<mx:Label text="Name:" fontSize="12"/>
				<mx:TextInput id="modelName" text="{model.modelName}" fontSize="12" 
							  valueCommit="{model.modelName = modelName.text}"/>
				<mx:Spacer width="100%"/>
			</mx:HBox>
			<mx:HBox width="100%">
				<mx:Label text="Source:" fontSize="12"/>
				<mx:TextInput id="modelSource" text="{model.source}" fontSize="12"
							  valueCommit="{model.source = modelSource.text}"/>
				<mx:Label text="Citation Key:" fontSize="12"/>
				<mx:TextInput id="modelCitation" text="{model.citeKey}" fontSize="12"
							  valueCommit="{model.citeKey = modelCitation.text}"/>	
			</mx:HBox>
			<mx:HBox height="30" width="100%">
				<mx:Button label="Show PowerLoom" click="showModelPowerLoom(event)"/>
				<mx:Spacer width="100%"/>
				<mx:Button label="Save Data" click="saveCurrentModel(event, false)" enabled="{saveAllowed}"/>
				<mx:Button label="Save &amp; Return" click="saveCurrentModel(event, true)" enabled="{saveAllowed}"/>
				<mx:Button label="Cancel" click="cancelSave(event)"/>
				<!-- <mx:Button label="Debug" click="doDebug(event)"/> -->
			</mx:HBox>
			
			<mx:VDividedBox width="100%" height="100%">
				<mx:HBox width="100%" height="30%">
					<mx:Panel id="cntrlVaribleList" width="33%" height="100%" 
							title="Controlled Variables"
								backgroundAlpha="{indepVaribleList.getStyle('borderAlpha')}" 
								backgroundColor="{indepVaribleList.getStyle('borderColor')}">
						<mx:List id="cntrlVbGrid" 
								dataProvider="{cntrlVbs}"
								labelField="nameValue"
								width="100%" 
								height="100%" 
								click="selectListElement(event);"
								editable="false"/>
					</mx:Panel>	
				
					<mx:Panel id="indepVaribleList" width="33%" height="100%" 
							title="Parameters"
								backgroundAlpha="{indepVaribleList.getStyle('borderAlpha')}" 
								backgroundColor="{indepVaribleList.getStyle('borderColor')}">
						<mx:List id="indepVbGrid" 
								dataProvider="{indepVbs}"
								labelField="nameValue"
								width="100%" 
								height="100%" 
								click="selectListElement(event);"
								editable="false"/>
					</mx:Panel>	
					
					<mx:Panel id="depVaribleList" width="33%" height="100%" 
							title="Measurements"
								backgroundAlpha="{depVaribleList.getStyle('borderAlpha')}" 
								backgroundColor="{depVaribleList.getStyle('borderColor')}">		
						<mx:List id="depVbGrid" 
								dataProvider="{depVbs}" 
								labelField="nameValue"
								width="100%" 
								height="100%" 
								click="selectListElement(event);"
								editable="false" />
					</mx:Panel>
				</mx:HBox> 	
				
				<mx:VBox id="dataGrid" label="Data" width="100%" height="100%">
				<mx:VBox id="activeObjectForm" label="CurrentObject" width="100%" height="20%">
				<mx:Form id="modelInfo" label="Model" height="40%" width="100%">
		 	    	<mx:FormHeading label="Experiment Info"/>
					<mx:FormItem label="Description" direction="horizontal" width="100%">
						<mx:TextArea id="descriptionField" height="120" width="100%"
							text="{model.description}" valueCommit="{model.description = descriptionField.text}"/>
					</mx:FormItem>
					<mx:FormItem label="Date/Time" direction="horizontal" width="100%">
						<mx:Text text="{model.dateTime}" width="100%"/> 
					</mx:FormItem>
				</mx:Form>
				</mx:VBox>
				</mx:VBox>
				<!--<sp:SpreadSheet id="sheet" 
			    		width="100%" 
			    		height="100%" 
			    		borderStyle="solid" 
						backgroundColor="#ffffff"
						backgroundAlpha="1"/>-->
			
			</mx:VDividedBox> 
		</mx:VBox>
	</mx:HDividedBox> 	
        
</mx:VBox>